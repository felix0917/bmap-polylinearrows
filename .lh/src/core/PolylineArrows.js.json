{
    "sourceFile": "src/core/PolylineArrows.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1645442232901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1645442727001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,10 +69,10 @@\n         // 每次更新前先清空所有箭头数据\n         that.clearArrows();\n \n         let step = that.step;\n-        let remainingL en = 0;\n-        let currrentLength = 0;\n+        let remainingLen = 0; // 剩余像素长度\n+        let currrentLen = 0;\n         let currentStart = that.pointToPixel(that.linePoints[0][0], that.linePoints[0][1]);\n         let arrowNode = {};\n         for (let i = 0; i < that.linePoints.length - 1; i++) {\n             let currentLinePoint = that.linePoints[i];\n@@ -94,13 +94,13 @@\n             } else {\n                 nodeDist = dy / Math.sin(rotation);\n             }\n \n-            if (Number(nodeDist) < Number(step - currrentLength)) { // 两节点间距过短\n-                currrentLength += nodeDist;\n+            if (Number(nodeDist) < Number(step - currrentLen)) { // 两节点间距过短\n+                currrentLen += nodeDist;\n                 currentStart = end;\n             } else {\n-                if (currrentLength == 0) {\n+                if (currrentLen == 0) {\n                     remainingLen = nodeDist % step;\n                     let splitNum = Math.floor(nodeDist / step);\n                     let Y = -Math.sin(rotation) * step;\n                     let X = Math.cos(rotation) * step;\n@@ -110,12 +110,12 @@\n                         currentStart = arrowNode;\n \n                         that.addArrow(arrowNode, rotation);\n                     }\n-                    currrentLength = remainingLen;\n+                    currrentLen = remainingLen;\n                     currentStart = end;\n                 } else {\n-                    let littleStep = step - currrentLength;\n+                    let littleStep = step - currrentLen;\n                     let Y = -Math.sin(rotation) * littleStep;\n                     let X = Math.cos(rotation) * littleStep;\n                     arrowNode.x = currentStart.x + X;\n                     arrowNode.y = currentStart.y + Y;\n@@ -133,9 +133,9 @@\n                         currentStart = arrowNode;\n \n                         that.addArrow(arrowNode, rotation);\n                     }\n-                    currrentLength = remainingLen;\n+                    currrentLen = remainingLen;\n                     currentStart = end;\n                 }\n             }\n         }\n"
                },
                {
                    "date": 1645445298851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,9 @@\n             } else {\n                 nodeDist = dy / Math.sin(rotation);\n             }\n \n-            if (Number(nodeDist) < Number(step - currrentLen)) { // 两节点间距过短\n+            if (Number(nodeDist + currrentLen) < Number(step)) { // 两节点间距过短\n                 currrentLen += nodeDist;\n                 currentStart = end;\n             } else {\n                 if (currrentLen == 0) {\n"
                },
                {
                    "date": 1645445672501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,9 +70,9 @@\n         that.clearArrows();\n \n         let step = that.step;\n         let remainingLen = 0; // 剩余像素长度\n-        let currrentLen = 0;\n+        // let currrentLen = 0;\n         let currentStart = that.pointToPixel(that.linePoints[0][0], that.linePoints[0][1]);\n         let arrowNode = {};\n         for (let i = 0; i < that.linePoints.length - 1; i++) {\n             let currentLinePoint = that.linePoints[i];\n@@ -94,14 +94,13 @@\n             } else {\n                 nodeDist = dy / Math.sin(rotation);\n             }\n \n-            if (Number(nodeDist + currrentLen) < Number(step)) { // 两节点间距过短\n-                currrentLen += nodeDist;\n+            if (Number(nodeDist + remainingLen) < Number(step)) { // 两节点间距过短\n+                remainingLen += nodeDist;\n                 currentStart = end;\n             } else {\n-                if (currrentLen == 0) {\n-                    remainingLen = nodeDist % step;\n+                if (remainingLen == 0) {\n                     let splitNum = Math.floor(nodeDist / step);\n                     let Y = -Math.sin(rotation) * step;\n                     let X = Math.cos(rotation) * step;\n                     for (let i = 0; i < splitNum; i++) {\n@@ -110,12 +109,14 @@\n                         currentStart = arrowNode;\n \n                         that.addArrow(arrowNode, rotation);\n                     }\n-                    currrentLen = remainingLen;\n+\n+                    remainingLen = nodeDist % step;\n+                    // currrentLen = remainingLen;\n                     currentStart = end;\n                 } else {\n-                    let littleStep = step - currrentLen;\n+                    let littleStep = step - remainingLen;\n                     let Y = -Math.sin(rotation) * littleStep;\n                     let X = Math.cos(rotation) * littleStep;\n                     arrowNode.x = currentStart.x + X;\n                     arrowNode.y = currentStart.y + Y;\n@@ -133,9 +134,9 @@\n                         currentStart = arrowNode;\n \n                         that.addArrow(arrowNode, rotation);\n                     }\n-                    currrentLen = remainingLen;\n+                    // currrentLen = remainingLen;\n                     currentStart = end;\n                 }\n             }\n         }\n"
                },
                {
                    "date": 1645445710873,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,9 +70,8 @@\n         that.clearArrows();\n \n         let step = that.step;\n         let remainingLen = 0; // 剩余像素长度\n-        // let currrentLen = 0;\n         let currentStart = that.pointToPixel(that.linePoints[0][0], that.linePoints[0][1]);\n         let arrowNode = {};\n         for (let i = 0; i < that.linePoints.length - 1; i++) {\n             let currentLinePoint = that.linePoints[i];\n@@ -111,9 +110,8 @@\n                         that.addArrow(arrowNode, rotation);\n                     }\n \n                     remainingLen = nodeDist % step;\n-                    // currrentLen = remainingLen;\n                     currentStart = end;\n                 } else {\n                     let littleStep = step - remainingLen;\n                     let Y = -Math.sin(rotation) * littleStep;\n@@ -134,9 +132,8 @@\n                         currentStart = arrowNode;\n \n                         that.addArrow(arrowNode, rotation);\n                     }\n-                    // currrentLen = remainingLen;\n                     currentStart = end;\n                 }\n             }\n         }\n"
                },
                {
                    "date": 1645445754122,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,9 +93,10 @@\n             } else {\n                 nodeDist = dy / Math.sin(rotation);\n             }\n \n-            if (Number(nodeDist + remainingLen) < Number(step)) { // 两节点间距过短\n+            if (Number(nodeDist + remainingLen) < Number(step)) {\n+                // 两节点间距过短\n                 remainingLen += nodeDist;\n                 currentStart = end;\n             } else {\n                 if (remainingLen == 0) {\n"
                },
                {
                    "date": 1645445774849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,10 +84,13 @@\n                 // 意味着折线中节点太近，忽略这段距离\n                 continue;\n             }\n \n-            let rotation = Math.atan2(dy, dx); // 两点旋转角度差\n-            let nodeDist; //  两点像素距离\n+            // 两点旋转角度差\n+            let rotation = Math.atan2(dy, dx);\n+\n+            // 两点像素距离\n+            let nodeDist;\n             if (rotation === 0) {\n                 // dy=0，则rotaion=0\n                 nodeDist = dx;\n             } else {\n"
                },
                {
                    "date": 1645446025335,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,22 +3,21 @@\n class PolylineArrows {\n     constructor(mapType, map, data, icon, opts = {}) {\n         this.mapType = mapType; // 地图类型，支持['BMap','BMapGL']\n         this.map = map // 地图实例化对象\n-        this.data = data; // geojson格式的polyline数据\n+        this.data = data; // GeoJSON格式的Polyline数据\n         this.icon = icon; // 箭头图标\n         this.step = defaultValue(opts.step, 90); // 箭头间距，单位px\n         this.iconSize = defaultValue(opts.iconSize, { x: 12, y: 12 }); // 箭头大小，单位px\n         this.correctAngle = defaultValue(opts.correctAngle, 0); // 图标角度校正：图标的起始角度应该对准水平轴朝右（---->），单位：角度制\n \n-        // 私有变量\n         this.linePoints = []; // 扁平化线路坐标数组\n         this.arrowOverlays = []; // 箭头覆盖物容器\n         this.refreshHandlerFunc = null; // 箭头更新处理函数\n \n         this.parseLineData();\n         this.initRefreshEvent();\n-        this.dispatchArrows(); // 初始化加载箭头\n+        this.dispatchArrows();\n     }\n \n     /**\n      * 解析线路数据\n@@ -65,9 +64,8 @@\n     * 箭头绘制调度中心\n     */\n     dispatchArrows() {\n         let that = this;\n-        // 每次更新前先清空所有箭头数据\n         that.clearArrows();\n \n         let step = that.step;\n         let remainingLen = 0; // 剩余像素长度\n@@ -78,9 +76,9 @@\n             let nextLinePoint = that.linePoints[i + 1];\n \n             let start = that.pointToPixel(currentLinePoint[0], currentLinePoint[1]);\n             let end = that.pointToPixel(nextLinePoint[0], nextLinePoint[1]);\n-            let [dx, dy] = [end.x - start.x, start.y - end.y];\n+            let [dx, dy] = [end.x - start.x, end.y - start.y];\n             if (dx === 0 && dy === 0) {\n                 // 意味着折线中节点太近，忽略这段距离\n                 continue;\n             }\n"
                },
                {
                    "date": 1645446040740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -101,9 +101,9 @@\n                 currentStart = end;\n             } else {\n                 if (remainingLen == 0) {\n                     let splitNum = Math.floor(nodeDist / step);\n-                    let Y = -Math.sin(rotation) * step;\n+                    let Y = Math.sin(rotation) * step;\n                     let X = Math.cos(rotation) * step;\n                     for (let i = 0; i < splitNum; i++) {\n                         arrowNode.x = currentStart.x + X;\n                         arrowNode.y = currentStart.y + Y;\n@@ -115,9 +115,9 @@\n                     remainingLen = nodeDist % step;\n                     currentStart = end;\n                 } else {\n                     let littleStep = step - remainingLen;\n-                    let Y = -Math.sin(rotation) * littleStep;\n+                    let Y = Math.sin(rotation) * littleStep;\n                     let X = Math.cos(rotation) * littleStep;\n                     arrowNode.x = currentStart.x + X;\n                     arrowNode.y = currentStart.y + Y;\n                     currentStart = arrowNode;\n"
                },
                {
                    "date": 1645446066281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n             let nextLinePoint = that.linePoints[i + 1];\n \n             let start = that.pointToPixel(currentLinePoint[0], currentLinePoint[1]);\n             let end = that.pointToPixel(nextLinePoint[0], nextLinePoint[1]);\n-            let [dx, dy] = [end.x - start.x, end.y - start.y];\n+            let [dx, dy] = [end.x - start.x, end.y-start.y];\n             if (dx === 0 && dy === 0) {\n                 // 意味着折线中节点太近，忽略这段距离\n                 continue;\n             }\n@@ -101,9 +101,9 @@\n                 currentStart = end;\n             } else {\n                 if (remainingLen == 0) {\n                     let splitNum = Math.floor(nodeDist / step);\n-                    let Y = Math.sin(rotation) * step;\n+                    let Y = -Math.sin(rotation) * step;\n                     let X = Math.cos(rotation) * step;\n                     for (let i = 0; i < splitNum; i++) {\n                         arrowNode.x = currentStart.x + X;\n                         arrowNode.y = currentStart.y + Y;\n@@ -115,9 +115,9 @@\n                     remainingLen = nodeDist % step;\n                     currentStart = end;\n                 } else {\n                     let littleStep = step - remainingLen;\n-                    let Y = Math.sin(rotation) * littleStep;\n+                    let Y = -Math.sin(rotation) * littleStep;\n                     let X = Math.cos(rotation) * littleStep;\n                     arrowNode.x = currentStart.x + X;\n                     arrowNode.y = currentStart.y + Y;\n                     currentStart = arrowNode;\n"
                },
                {
                    "date": 1645446084226,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n             let nextLinePoint = that.linePoints[i + 1];\n \n             let start = that.pointToPixel(currentLinePoint[0], currentLinePoint[1]);\n             let end = that.pointToPixel(nextLinePoint[0], nextLinePoint[1]);\n-            let [dx, dy] = [end.x - start.x, end.y-start.y];\n+            let [dx, dy] = [end.x - start.x, start.y - end.y];\n             if (dx === 0 && dy === 0) {\n                 // 意味着折线中节点太近，忽略这段距离\n                 continue;\n             }\n"
                },
                {
                    "date": 1645446122294,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,9 @@\n             let start = that.pointToPixel(currentLinePoint[0], currentLinePoint[1]);\n             let end = that.pointToPixel(nextLinePoint[0], nextLinePoint[1]);\n             let [dx, dy] = [end.x - start.x, start.y - end.y];\n             if (dx === 0 && dy === 0) {\n-                // 意味着折线中节点太近，忽略这段距离\n+                // 两节点太近，忽略这段距离\n                 continue;\n             }\n \n             // 两点旋转角度差\n"
                },
                {
                    "date": 1645446162200,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,9 +88,9 @@\n \n             // 两点像素距离\n             let nodeDist;\n             if (rotation === 0) {\n-                // dy=0，则rotaion=0\n+                // dy=0的情况\n                 nodeDist = dx;\n             } else {\n                 nodeDist = dy / Math.sin(rotation);\n             }\n"
                },
                {
                    "date": 1645446555354,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,9 +156,8 @@\n             this.drawArrow(arrowPoint, -currrentAngle);\n         }\n     }\n \n-\n     /**\n      * 使用百度地图API绘制箭头\n      * @param arrowPoint 箭头像素坐标\n      * @param rotation 旋转角度\n"
                }
            ],
            "date": 1645442232901,
            "name": "Commit-0",
            "content": "import defaultValue from '../utils/defaultValue';\n\nclass PolylineArrows {\n    constructor(mapType, map, data, icon, opts = {}) {\n        this.mapType = mapType; // 地图类型，支持['BMap','BMapGL']\n        this.map = map // 地图实例化对象\n        this.data = data; // geojson格式的polyline数据\n        this.icon = icon; // 箭头图标\n        this.step = defaultValue(opts.step, 90); // 箭头间距，单位px\n        this.iconSize = defaultValue(opts.iconSize, { x: 12, y: 12 }); // 箭头大小，单位px\n        this.correctAngle = defaultValue(opts.correctAngle, 0); // 图标角度校正：图标的起始角度应该对准水平轴朝右（---->），单位：角度制\n\n        // 私有变量\n        this.linePoints = []; // 扁平化线路坐标数组\n        this.arrowOverlays = []; // 箭头覆盖物容器\n        this.refreshHandlerFunc = null; // 箭头更新处理函数\n\n        this.parseLineData();\n        this.initRefreshEvent();\n        this.dispatchArrows(); // 初始化加载箭头\n    }\n\n    /**\n     * 解析线路数据\n     */\n    parseLineData() {\n        let geo = this.data.geometry;\n        if (!geo) return;\n\n        let { type } = geo;\n        switch (type) {\n            case 'LineString':\n                this.linePoints = geo.coordinates;\n                break;\n            case 'MultiLineString':\n                this.linePoints = geo.coordinates.flat();\n                break;\n            default:\n                console.error('error polyline data!');\n                break;\n        }\n    }\n\n    /**\n     * 初始化箭头更新事件\n     * 地图平移和缩放结束时触发\n     */\n    initRefreshEvent() {\n        this.refreshHandlerFunc = this.refreshHandler.bind(this);\n\n        if (this.linePoints && this.linePoints.length > 1) {\n            this.map.addEventListener('moveend', this.refreshHandlerFunc);\n            this.map.addEventListener('zoomend', this.refreshHandlerFunc);\n        }\n    }\n\n    /**\n     * 地图平移缩放结束事件处理\n     */\n    refreshHandler() {\n        this.dispatchArrows();\n    }\n\n    /**\n    * 箭头绘制调度中心\n    */\n    dispatchArrows() {\n        let that = this;\n        // 每次更新前先清空所有箭头数据\n        that.clearArrows();\n\n        let step = that.step;\n        let remainingL en = 0;\n        let currrentLength = 0;\n        let currentStart = that.pointToPixel(that.linePoints[0][0], that.linePoints[0][1]);\n        let arrowNode = {};\n        for (let i = 0; i < that.linePoints.length - 1; i++) {\n            let currentLinePoint = that.linePoints[i];\n            let nextLinePoint = that.linePoints[i + 1];\n\n            let start = that.pointToPixel(currentLinePoint[0], currentLinePoint[1]);\n            let end = that.pointToPixel(nextLinePoint[0], nextLinePoint[1]);\n            let [dx, dy] = [end.x - start.x, start.y - end.y];\n            if (dx === 0 && dy === 0) {\n                // 意味着折线中节点太近，忽略这段距离\n                continue;\n            }\n\n            let rotation = Math.atan2(dy, dx); // 两点旋转角度差\n            let nodeDist; //  两点像素距离\n            if (rotation === 0) {\n                // dy=0，则rotaion=0\n                nodeDist = dx;\n            } else {\n                nodeDist = dy / Math.sin(rotation);\n            }\n\n            if (Number(nodeDist) < Number(step - currrentLength)) { // 两节点间距过短\n                currrentLength += nodeDist;\n                currentStart = end;\n            } else {\n                if (currrentLength == 0) {\n                    remainingLen = nodeDist % step;\n                    let splitNum = Math.floor(nodeDist / step);\n                    let Y = -Math.sin(rotation) * step;\n                    let X = Math.cos(rotation) * step;\n                    for (let i = 0; i < splitNum; i++) {\n                        arrowNode.x = currentStart.x + X;\n                        arrowNode.y = currentStart.y + Y;\n                        currentStart = arrowNode;\n\n                        that.addArrow(arrowNode, rotation);\n                    }\n                    currrentLength = remainingLen;\n                    currentStart = end;\n                } else {\n                    let littleStep = step - currrentLength;\n                    let Y = -Math.sin(rotation) * littleStep;\n                    let X = Math.cos(rotation) * littleStep;\n                    arrowNode.x = currentStart.x + X;\n                    arrowNode.y = currentStart.y + Y;\n                    currentStart = arrowNode;\n\n                    that.addArrow(arrowNode, rotation);\n\n                    remainingLen = (nodeDist - littleStep) % step;\n                    let splitNum = Math.floor((nodeDist - littleStep) / step);\n                    Y = -Math.sin(rotation) * step;\n                    X = Math.cos(rotation) * step;\n                    for (let i = 0; i < splitNum; i++) {\n                        arrowNode.x = currentStart.x + X;\n                        arrowNode.y = currentStart.y + Y;\n                        currentStart = arrowNode;\n\n                        that.addArrow(arrowNode, rotation);\n                    }\n                    currrentLength = remainingLen;\n                    currentStart = end;\n                }\n            }\n        }\n    }\n\n    /**\n     * 新增箭头\n     * @param arrowNode 箭头对象\n     * @param rotation 旋转角度\n     */\n    addArrow(arrowNode, rotation) {\n        let seeExtent = this.map.getBounds();\n        let arrowPoint = this.pixelToPoint(arrowNode.x, arrowNode.y);\n\n        // 仅在屏幕可视区域内加载\n        if (seeExtent.containsPoint(arrowPoint)) {\n            let currrentAngle = (rotation / Math.PI) * 180 - this.correctAngle;\n            this.drawArrow(arrowPoint, -currrentAngle);\n        }\n    }\n\n\n    /**\n     * 使用百度地图API绘制箭头\n     * @param arrowPoint 箭头像素坐标\n     * @param rotation 旋转角度\n     */\n    drawArrow(arrowPoint, rotation) {\n        let marker = this.createMarker(arrowPoint);\n        marker.setRotation(rotation);\n\n        this.map.addOverlay(marker);\n        this.arrowOverlays.push(marker);\n    }\n\n    /**\n     * 清除箭头\n     */\n    clearArrows() {\n        this.arrowOverlays.forEach((overlay) => {\n            this.map.removeOverlay(overlay);\n        });\n\n        this.arrowOverlays = [];\n    }\n\n    /**\n     * 设置箭头可见性\n     * @param visible 可见性\n     */\n    setArrowsVisible(visible) {\n        this.arrowOverlays.forEach((overlay) => {\n            if (visible) {\n                overlay.show();\n            } else {\n                overlay.hide();\n            }\n        });\n    }\n\n    /**\n     * 更新箭头数据\n     * @param newData 新箭头数据\n     */\n    updateData(newData) {\n        this.data = newData;\n        this.parseLineData();\n        this.clearArrows();\n        this.dispatchArrows();\n    }\n\n    /**\n     * 经纬度坐标转屏幕坐标\n     * @param lng 经度\n     * @param lat 纬度\n     */\n    pointToPixel(lng, lat) {\n        let pixel;\n        switch (this.mapType) {\n            case 'BMap':\n                pixel = this.map.pointToPixel(new BMap.Point(lng, lat));\n                break;\n            case 'BMapGL':\n                pixel = this.map.pointToPixel(new BMapGL.Point(lng, lat));\n                break;\n            default:\n                console.log(`请输入正确的地图构造函数：['BMap','BMapGL']中的一种！`);\n                break;\n        }\n\n        return pixel;\n    }\n\n    /**\n    * 屏幕坐标转经纬度坐标\n    * @param x 屏幕坐标x\n    * @param y 屏幕坐标y\n    */\n    pixelToPoint(x, y) {\n        let point;\n        switch (this.mapType) {\n            case 'BMap':\n                point = this.map.pixelToPoint(new BMap.Pixel(x, y));\n                break;\n            case 'BMapGL':\n                point = this.map.pixelToPoint(new BMapGL.Pixel(x, y));\n                break;\n            default:\n                console.log(`请输入正确的地图构造函数：['BMap','BMapGL']中的一种！`);\n                break;\n        }\n\n        return point;\n    }\n\n    /**\n     * 创建marker\n     * @param icon 图标\n     * @param point 坐标点\n     */\n    createMarker(point) {\n        let myIcon;\n        let marker;\n        switch (this.mapType) {\n            case 'BMap':\n                myIcon = new BMap.Icon(this.icon, new BMap.Size(this.iconSize.x, this.iconSize.y));\n                marker = new BMap.Marker(point, {\n                    icon: myIcon,\n                });\n                break;\n            case 'BMapGL':\n                myIcon = new BMapGL.Icon(this.icon, new BMapGL.Size(this.iconSize.x, this.iconSize.y));\n                marker = new BMapGL.Marker(point, {\n                    icon: myIcon,\n                });\n                break;\n            default:\n                console.log(`请输入正确的地图构造函数：['BMap','BMapGL']中的一种！`);\n                break;\n        }\n\n        return marker;\n    }\n\n    /**\n    * 析构函数\n    */\n    destory() {\n        this.clearArrows();\n\n        this.map.removeEventListener('moveend', this.moveendHandlerFunc);\n        this.map.removeEventListener('zoomend', this.zoomendHandlerFunc);\n    }\n}\n\nexport default PolylineArrows;"
        }
    ]
}