{"version":3,"file":"bmap-polylinearrows.min.js","sources":["../src/utils/defaultValue.js","../src/core/PolylineArrows.js"],"sourcesContent":["/**\n * Returns the first parameter if not undefined, otherwise the second parameter.\n * Useful for setting a default value for a parameter.\n *\n * @function\n *\n * @param {*} a\n * @param {*} b\n * @returns {*} Returns the first parameter if not undefined, otherwise the second parameter.\n *\n * @example\n * param = Cesium.defaultValue(param, 'default');\n */\n function defaultValue(a, b) {\n    if (a !== undefined && a !== null) {\n      return a;\n    }\n    return b;\n  }\n  \n  /**\n   * A frozen empty object that can be used as the default value for options passed as\n   * an object literal.\n   * @type {Object}\n   * @memberof defaultValue\n   */\n  defaultValue.EMPTY_OBJECT = Object.freeze({});\n  \n  export default defaultValue;","import defaultValue from '../utils/defaultValue';\n\nclass PolylineArrows {\n    constructor(mapType, map, data, icon, opts = {}) {\n        this.mapType = mapType; // 地图类型，支持['BMap','BMapGL']\n        this.map = map // 地图实例化对象\n        this.data = data; // GeoJSON格式的Polyline数据\n        this.icon = icon; // 箭头图标\n        this.step = defaultValue(opts.step, 90); // 箭头间距，单位px\n        this.iconSize = defaultValue(opts.iconSize, { x: 12, y: 12 }); // 箭头大小，单位px\n        this.correctAngle = defaultValue(opts.correctAngle, 0); // 图标角度校正：图标的起始角度应该对准水平轴朝右（---->），单位：角度制\n\n        this.linePoints = []; // 扁平化线路坐标数组\n        this.arrowOverlays = []; // 箭头覆盖物容器\n        this.refreshHandlerFunc = null; // 箭头更新处理函数\n\n        this.parseLineData();\n        this.initRefreshEvent();\n        this.dispatchArrows();\n    }\n\n    /**\n     * 解析线路数据\n     */\n    parseLineData() {\n        let geo = this.data.geometry;\n        if (!geo) return;\n\n        let { type } = geo;\n        switch (type) {\n            case 'LineString':\n                this.linePoints = geo.coordinates;\n                break;\n            case 'MultiLineString':\n                this.linePoints = geo.coordinates.flat();\n                break;\n            default:\n                console.error('error polyline data!');\n                break;\n        }\n    }\n\n    /**\n     * 初始化箭头更新事件\n     * 地图平移和缩放结束时触发\n     */\n    initRefreshEvent() {\n        this.refreshHandlerFunc = this.refreshHandler.bind(this);\n\n        if (this.linePoints && this.linePoints.length > 1) {\n            this.map.addEventListener('moveend', this.refreshHandlerFunc);\n            this.map.addEventListener('zoomend', this.refreshHandlerFunc);\n        }\n    }\n\n    /**\n     * 地图平移缩放结束事件处理\n     */\n    refreshHandler() {\n        this.dispatchArrows();\n    }\n\n    /**\n    * 箭头绘制调度中心\n    */\n    dispatchArrows() {\n        let that = this;\n        that.clearArrows();\n\n        let step = that.step;\n        let remainingLen = 0; // 剩余像素长度\n        let currentStart = that.pointToPixel(that.linePoints[0][0], that.linePoints[0][1]);\n        let arrowNode = {};\n        for (let i = 0; i < that.linePoints.length - 1; i++) {\n            let currentLinePoint = that.linePoints[i];\n            let nextLinePoint = that.linePoints[i + 1];\n\n            let start = that.pointToPixel(currentLinePoint[0], currentLinePoint[1]);\n            let end = that.pointToPixel(nextLinePoint[0], nextLinePoint[1]);\n            let [dx, dy] = [end.x - start.x, start.y - end.y];\n            if (dx === 0 && dy === 0) {\n                // 意味着折线中节点太近，忽略这段距离\n                continue;\n            }\n\n            // 两点旋转角度差\n            let rotation = Math.atan2(dy, dx);\n\n            // 两点像素距离\n            let nodeDist;\n            if (rotation === 0) {\n                // dy=0，则rotaion=0\n                nodeDist = dx;\n            } else {\n                nodeDist = dy / Math.sin(rotation);\n            }\n\n            if (Number(nodeDist + remainingLen) < Number(step)) {\n                // 两节点间距过短\n                remainingLen += nodeDist;\n                currentStart = end;\n            } else {\n                if (remainingLen == 0) {\n                    let splitNum = Math.floor(nodeDist / step);\n                    let Y = -Math.sin(rotation) * step;\n                    let X = Math.cos(rotation) * step;\n                    for (let i = 0; i < splitNum; i++) {\n                        arrowNode.x = currentStart.x + X;\n                        arrowNode.y = currentStart.y + Y;\n                        currentStart = arrowNode;\n\n                        that.addArrow(arrowNode, rotation);\n                    }\n\n                    remainingLen = nodeDist % step;\n                    currentStart = end;\n                } else {\n                    let littleStep = step - remainingLen;\n                    let Y = -Math.sin(rotation) * littleStep;\n                    let X = Math.cos(rotation) * littleStep;\n                    arrowNode.x = currentStart.x + X;\n                    arrowNode.y = currentStart.y + Y;\n                    currentStart = arrowNode;\n\n                    that.addArrow(arrowNode, rotation);\n\n                    remainingLen = (nodeDist - littleStep) % step;\n                    let splitNum = Math.floor((nodeDist - littleStep) / step);\n                    Y = -Math.sin(rotation) * step;\n                    X = Math.cos(rotation) * step;\n                    for (let i = 0; i < splitNum; i++) {\n                        arrowNode.x = currentStart.x + X;\n                        arrowNode.y = currentStart.y + Y;\n                        currentStart = arrowNode;\n\n                        that.addArrow(arrowNode, rotation);\n                    }\n                    currentStart = end;\n                }\n            }\n        }\n    }\n\n    /**\n     * 新增箭头\n     * @param arrowNode 箭头对象\n     * @param rotation 旋转角度\n     */\n    addArrow(arrowNode, rotation) {\n        let seeExtent = this.map.getBounds();\n        let arrowPoint = this.pixelToPoint(arrowNode.x, arrowNode.y);\n\n        // 仅在屏幕可视区域内加载\n        if (seeExtent.containsPoint(arrowPoint)) {\n            let currrentAngle = (rotation / Math.PI) * 180 - this.correctAngle;\n            this.drawArrow(arrowPoint, -currrentAngle);\n        }\n    }\n\n\n    /**\n     * 使用百度地图API绘制箭头\n     * @param arrowPoint 箭头像素坐标\n     * @param rotation 旋转角度\n     */\n    drawArrow(arrowPoint, rotation) {\n        let marker = this.createMarker(arrowPoint);\n        marker.setRotation(rotation);\n\n        this.map.addOverlay(marker);\n        this.arrowOverlays.push(marker);\n    }\n\n    /**\n     * 清除箭头\n     */\n    clearArrows() {\n        this.arrowOverlays.forEach((overlay) => {\n            this.map.removeOverlay(overlay);\n        });\n\n        this.arrowOverlays = [];\n    }\n\n    /**\n     * 设置箭头可见性\n     * @param visible 可见性\n     */\n    setArrowsVisible(visible) {\n        this.arrowOverlays.forEach((overlay) => {\n            if (visible) {\n                overlay.show();\n            } else {\n                overlay.hide();\n            }\n        });\n    }\n\n    /**\n     * 更新箭头数据\n     * @param newData 新箭头数据\n     */\n    updateData(newData) {\n        this.data = newData;\n        this.parseLineData();\n        this.clearArrows();\n        this.dispatchArrows();\n    }\n\n    /**\n     * 经纬度坐标转屏幕坐标\n     * @param lng 经度\n     * @param lat 纬度\n     */\n    pointToPixel(lng, lat) {\n        let pixel;\n        switch (this.mapType) {\n            case 'BMap':\n                pixel = this.map.pointToPixel(new BMap.Point(lng, lat));\n                break;\n            case 'BMapGL':\n                pixel = this.map.pointToPixel(new BMapGL.Point(lng, lat));\n                break;\n            default:\n                console.log(`请输入正确的地图构造函数：['BMap','BMapGL']中的一种！`);\n                break;\n        }\n\n        return pixel;\n    }\n\n    /**\n    * 屏幕坐标转经纬度坐标\n    * @param x 屏幕坐标x\n    * @param y 屏幕坐标y\n    */\n    pixelToPoint(x, y) {\n        let point;\n        switch (this.mapType) {\n            case 'BMap':\n                point = this.map.pixelToPoint(new BMap.Pixel(x, y));\n                break;\n            case 'BMapGL':\n                point = this.map.pixelToPoint(new BMapGL.Pixel(x, y));\n                break;\n            default:\n                console.log(`请输入正确的地图构造函数：['BMap','BMapGL']中的一种！`);\n                break;\n        }\n\n        return point;\n    }\n\n    /**\n     * 创建marker\n     * @param icon 图标\n     * @param point 坐标点\n     */\n    createMarker(point) {\n        let myIcon;\n        let marker;\n        switch (this.mapType) {\n            case 'BMap':\n                myIcon = new BMap.Icon(this.icon, new BMap.Size(this.iconSize.x, this.iconSize.y));\n                marker = new BMap.Marker(point, {\n                    icon: myIcon,\n                });\n                break;\n            case 'BMapGL':\n                myIcon = new BMapGL.Icon(this.icon, new BMapGL.Size(this.iconSize.x, this.iconSize.y));\n                marker = new BMapGL.Marker(point, {\n                    icon: myIcon,\n                });\n                break;\n            default:\n                console.log(`请输入正确的地图构造函数：['BMap','BMapGL']中的一种！`);\n                break;\n        }\n\n        return marker;\n    }\n\n    /**\n    * 析构函数\n    */\n    destory() {\n        this.clearArrows();\n\n        this.map.removeEventListener('moveend', this.moveendHandlerFunc);\n        this.map.removeEventListener('zoomend', this.zoomendHandlerFunc);\n    }\n}\n\nexport default PolylineArrows;"],"names":["defaultValue","a","b","EMPTY_OBJECT","Object","freeze","mapType","map","data","icon","opts","step","iconSize","x","y","correctAngle","linePoints","arrowOverlays","refreshHandlerFunc","parseLineData","initRefreshEvent","dispatchArrows","geo","this","geometry","type","coordinates","flat","console","error","refreshHandler","bind","length","addEventListener","that","clearArrows","remainingLen","currentStart","pointToPixel","arrowNode","i","currentLinePoint","nextLinePoint","start","end","dx","dy","rotation","Math","atan2","nodeDist","sin","Number","splitNum","floor","Y","X","cos","addArrow","littleStep","seeExtent","getBounds","arrowPoint","pixelToPoint","containsPoint","currrentAngle","PI","drawArrow","marker","createMarker","setRotation","addOverlay","push","forEach","overlay","_this","removeOverlay","visible","show","hide","newData","lng","lat","pixel","BMap","Point","BMapGL","log","point","Pixel","myIcon","Icon","Size","Marker","removeEventListener","moveendHandlerFunc","zoomendHandlerFunc"],"mappings":"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"}